var documenterSearchIndex = {"docs":
[{"location":"manual/denoising/#全息降噪算法","page":"全息降噪算法","title":"全息降噪算法","text":"","category":"section"},{"location":"manual/denoising/#空域掩膜法（SDM）","page":"全息降噪算法","title":"空域掩膜法（SDM）","text":"","category":"section"},{"location":"manual/denoising/","page":"全息降噪算法","title":"全息降噪算法","text":"一个简单的演示案例如下：","category":"page"},{"location":"manual/denoising/","page":"全息降噪算法","title":"全息降噪算法","text":"holo = load_holo(path, \"xxx.bmp\"; convert=true)\nFFTW.set_num_threads(Sys.CPU_THREADS)\nP = plan_rfft(holo)\t# or P = plan_fft(holo)\n# Parameter\nN = 2\nNx, Ny = size(holo) .÷ N\nDx, Dy = 50, 100\nscale = 600\n\nsdm_img = sdm(holo, (Nx, Ny), (Dx, Dy), P, scale)","category":"page"},{"location":"manual/denoising/","page":"全息降噪算法","title":"全息降噪算法","text":"note: Note\n更多的用法，可以通过输入如下：>julia?\nhelp>sdm来获取sdm函数的更多用法．","category":"page"},{"location":"manual/denoising/#冗余散斑降噪法（RSE）","page":"全息降噪算法","title":"冗余散斑降噪法（RSE）","text":"","category":"section"},{"location":"manual/denoising/","page":"全息降噪算法","title":"全息降噪算法","text":"一个简单的演示案例如下：","category":"page"},{"location":"manual/denoising/","page":"全息降噪算法","title":"全息降噪算法","text":"holo = load_holo(path, \"xxx.bmp\"; convert=true)\nFFTW.set_num_threads(Sys.CPU_THREADS)\nP = plan_rfft(holo)\t# or P = plan_fft(holo)\n# Parameter\nN = 2\nNx, Ny = size(holo) .÷ N\nDx, Dy = 50, 100\nscale = 600\n\nsdm_img = rse(holo, (Nx, Ny), (Dx, Dy), P, scale)","category":"page"},{"location":"manual/denoising/","page":"全息降噪算法","title":"全息降噪算法","text":"note: Note\n更多的用法，可以通过输入如下：>julia?\nhelp>rse来获取rse函数的更多用法．","category":"page"},{"location":"manual/denoising/#低维重建法（LDR）","page":"全息降噪算法","title":"低维重建法（LDR）","text":"","category":"section"},{"location":"manual/denoising/","page":"全息降噪算法","title":"全息降噪算法","text":"一个简单的演示案例如下：","category":"page"},{"location":"manual/denoising/","page":"全息降噪算法","title":"全息降噪算法","text":"holo = load_holo(path, \"xxx.bmp\"; convert=true)\nFFTW.set_num_threads(Sys.CPU_THREADS)\n\n# Parameter\nN = 2\nP = plan_rfft(similar(holo, size(holo) .÷ N))\n# or P = plan_fft(similar(holo, size(holo) .÷ N))\n\nDx, Dy = 50, 100\nscale = 600\n\nldr_img = ldr(holo, N, (Dx, Dy), P, scale)","category":"page"},{"location":"manual/denoising/","page":"全息降噪算法","title":"全息降噪算法","text":"note: Note\n更多的用法，可以通过输入如下：>julia?\nhelp>ldr来获取ldr函数的更多用法．","category":"page"},{"location":"manual/function/#函数库","page":"函数库","title":"函数库","text":"","category":"section"},{"location":"manual/function/#全息处理","page":"函数库","title":"全息处理","text":"","category":"section"},{"location":"manual/function/","page":"函数库","title":"函数库","text":"HoloProcessing.brightness\nHoloProcessing.load_holo\nHoloProcessing.normalize\nHoloProcessing.normalize!\nHoloProcessing.color\nHoloProcessing.reconst","category":"page"},{"location":"manual/function/#全息降噪","page":"函数库","title":"全息降噪","text":"","category":"section"},{"location":"manual/function/","page":"函数库","title":"函数库","text":"HoloProcessing.make_sub_holo!\nHoloProcessing.reconst_tensor!","category":"page"},{"location":"manual/function/#空域掩膜法实现","page":"函数库","title":"空域掩膜法实现","text":"","category":"section"},{"location":"manual/function/","page":"函数库","title":"函数库","text":"HoloProcessing.sdm\nHoloProcessing.sdm_core!","category":"page"},{"location":"manual/function/#冗余散斑降噪法实现","page":"函数库","title":"冗余散斑降噪法实现","text":"","category":"section"},{"location":"manual/function/","page":"函数库","title":"函数库","text":"HoloProcessing.rse\nHoloProcessing.rse_core!","category":"page"},{"location":"manual/function/#低维重建法实现","page":"函数库","title":"低维重建法实现","text":"","category":"section"},{"location":"manual/function/","page":"函数库","title":"函数库","text":"HoloProcessing.ldr\nHoloProcessing.ldr_core!\nHoloProcessing.ldr_denoising!\nHoloProcessing.ldr_aggregation!","category":"page"},{"location":"manual/function/#评价方法","page":"函数库","title":"评价方法","text":"","category":"section"},{"location":"manual/function/","page":"函数库","title":"函数库","text":"HoloProcessing.contrast\nHoloProcessing.ssi\nHoloProcessing.smpi\nHoloProcessing.enl","category":"page"},{"location":"manual/evaluating/#质量评价指标","page":"质量评价指标","title":"质量评价指标","text":"","category":"section"},{"location":"manual/evaluating/#图像对比度（Contrast，C）","page":"质量评价指标","title":"图像对比度（Contrast，C）","text":"","category":"section"},{"location":"manual/evaluating/","page":"质量评价指标","title":"质量评价指标","text":"mathrmC = fracmu_mathrmIsigma_mathrmI","category":"page"},{"location":"manual/evaluating/","page":"质量评价指标","title":"质量评价指标","text":"其中mu_mathrmI和sigma_mathrmI分别表示图像的平均值及其标准差。 ","category":"page"},{"location":"manual/evaluating/","page":"质量评价指标","title":"质量评价指标","text":"C = contrast(img)","category":"page"},{"location":"manual/evaluating/#等效视数（Equivalent-Number-of-Looks，ENL）","page":"质量评价指标","title":"等效视数（Equivalent Number of Looks，ENL）","text":"","category":"section"},{"location":"manual/evaluating/","page":"质量评价指标","title":"质量评价指标","text":"mathrmENL = left(fracmu_mathrmIsigma_mathrmIright)^2","category":"page"},{"location":"manual/evaluating/","page":"质量评价指标","title":"质量评价指标","text":"其中mu_mathrmI和sigma_mathrmI分别表示图像的平均值及其标准差。 ENL通常用于测量不同的降噪滤波器的性能好坏，当ENL值较大时，表明图像比较平滑，这意味着图像的噪点突刺比较少，滤波器的降噪性能较好。","category":"page"},{"location":"manual/evaluating/","page":"质量评价指标","title":"质量评价指标","text":"ENL = enl(img)","category":"page"},{"location":"manual/evaluating/#散斑抑制系数（Speckle-Suppression-Index，SSI）","page":"质量评价指标","title":"散斑抑制系数（Speckle Suppression Index，SSI）","text":"","category":"section"},{"location":"manual/evaluating/","page":"质量评价指标","title":"质量评价指标","text":"mathrmSSI = fracsigma_mathrmfmu_mathrmf cdot fracmu_mathrmosigma_mathrmo","category":"page"},{"location":"manual/evaluating/","page":"质量评价指标","title":"质量评价指标","text":"其中sigma_mathrmo和 mu_mathrmo分别表示原始图像的标准差和均值。 类似地，sigma_mathrmf和mu_mathrmf分别是经过降噪滤波器降噪后的图像的标准差和均值。通常来说，图像的均值表示它的信息，而图像的标准差则表示它的噪声严重程度，因此，SSI越小意味着降噪滤波器的性能越好。","category":"page"},{"location":"manual/evaluating/","page":"质量评价指标","title":"质量评价指标","text":"SSI = ssi(noised=noised_img, filtered=filtered_img)","category":"page"},{"location":"manual/evaluating/#散斑抑制和均值保持指数（Speckle-Suppression-and-Mean-Preservation-Index，SMPI）","page":"质量评价指标","title":"散斑抑制和均值保持指数（Speckle Suppression and Mean Preservation Index，SMPI）","text":"","category":"section"},{"location":"manual/evaluating/","page":"质量评价指标","title":"质量评价指标","text":"mathrmSMPI=left(1+leftmu_mathrmf-mu_mathrmorightright) cdot fracsigma_mathrmfsigma_mathrmo","category":"page"},{"location":"manual/evaluating/","page":"质量评价指标","title":"质量评价指标","text":"与ENL和SSI相比，SMPI考虑了降噪后的图像和降噪前的图像之间的均值差异。当降噪后的图片均值过于偏离原有的图片均值时，SMPI的数值的可信度高于ENL和SSI。理论上，较小的SMPI值表示在均值保持和降噪方面，滤波器具有更好的性能。","category":"page"},{"location":"manual/evaluating/","page":"质量评价指标","title":"质量评价指标","text":"SMPI = smpi(noised=noised_img, filtered=filtered_img)","category":"page"},{"location":"manual/processing/#标准全息处理","page":"标准全息处理","title":"标准全息处理","text":"","category":"section"},{"location":"manual/processing/#全息图的读取","page":"标准全息处理","title":"全息图的读取","text":"","category":"section"},{"location":"manual/processing/#读取全息图，并将其转换为Float64类型的二维矩阵","page":"标准全息处理","title":"读取全息图，并将其转换为Float64类型的二维矩阵","text":"","category":"section"},{"location":"manual/processing/","page":"标准全息处理","title":"标准全息处理","text":"holo = load_holo(path, \"xxx.bmp\"; convert=true)","category":"page"},{"location":"manual/processing/","page":"标准全息处理","title":"标准全息处理","text":"其中：","category":"page"},{"location":"manual/processing/","page":"标准全息处理","title":"标准全息处理","text":"path 是存放全息图的路径\n\"xxx.bmp\"是全息图的名称（实验中全息图都是以及bmp格式存放的）\nconvert表示是否将其转换为Float64的矩阵","category":"page"},{"location":"manual/processing/#全息图的再现","page":"标准全息处理","title":"全息图的再现","text":"","category":"section"},{"location":"manual/processing/#对全息图实现数值再现（针对无透镜傅立叶变换全息图）","page":"标准全息处理","title":"对全息图实现数值再现（针对无透镜傅立叶变换全息图）","text":"","category":"section"},{"location":"manual/processing/#开启多线程","page":"标准全息处理","title":"开启多线程","text":"","category":"section"},{"location":"manual/processing/","page":"标准全息处理","title":"标准全息处理","text":"note: Note\n首先需要注意的是，由于julia的傅立叶变换实现是默认不开多线程（而matlab的傅立叶变换是默认开多线程的，这也是为什么如果直接使用fft函数，julia的性能会比matlab差）。因此，需要在建立P（后面会解释这个P是什么）之前开启傅立叶变换的多线程，如下：","category":"page"},{"location":"manual/processing/","page":"标准全息处理","title":"标准全息处理","text":"FFTW.set_num_threads(Sys.CPU_THREADS)","category":"page"},{"location":"manual/processing/","page":"标准全息处理","title":"标准全息处理","text":"其中，Sys.CPU_THREADS表示我们cpu核心数的最大数量，比如在12核cpu上，输入Sys.CPU_THREADS，则显示如下：","category":"page"},{"location":"manual/processing/","page":"标准全息处理","title":"标准全息处理","text":"julia> Sys.CPU_THREADS\n12","category":"page"},{"location":"manual/processing/#高效的傅立叶变换的实现","page":"标准全息处理","title":"高效的傅立叶变换的实现","text":"","category":"section"},{"location":"manual/processing/","page":"标准全息处理","title":"标准全息处理","text":"正常情况下，对图像进行傅立叶变换，其代码如下:","category":"page"},{"location":"manual/processing/","page":"标准全息处理","title":"标准全息处理","text":"fft_img = fft(holo)\n\n# 或者\nfft_img = fftshift(fft(fftshit(holo)))","category":"page"},{"location":"manual/processing/","page":"标准全息处理","title":"标准全息处理","text":"其中是否加上fftshifts其关系不大，fftshift的作用仅仅是对图像进行旋转而已。  ","category":"page"},{"location":"manual/processing/","page":"标准全息处理","title":"标准全息处理","text":"在实际的实现中，考虑到会多次执行傅立叶变换的操作。因此，一个更加具备效率的做法是","category":"page"},{"location":"manual/processing/","page":"标准全息处理","title":"标准全息处理","text":"P = plan_fft(holo)\nfft_img = P * holo","category":"page"},{"location":"manual/processing/","page":"标准全息处理","title":"标准全息处理","text":"在这里P是FFTW.cFFTWPlan，表示以后都打算对与holo同个维度的矩阵进行傅立叶变换。","category":"page"},{"location":"manual/processing/","page":"标准全息处理","title":"标准全息处理","text":"另外，由于我们知道无透镜傅立叶变换全息图的再现像，其+1级和-1级都是一样的。因此，为了提高效率和节省空间，我们并不需要重建出完整的图像，而是可以重建出一半即可，这通过改变P即可做到：","category":"page"},{"location":"manual/processing/","page":"标准全息处理","title":"标准全息处理","text":"P = plan_rfft(holo)\nfft_img = P * holo","category":"page"},{"location":"manual/processing/#总结","page":"标准全息处理","title":"总结","text":"","category":"section"},{"location":"manual/processing/","page":"标准全息处理","title":"标准全息处理","text":"总的来说，一个开启了多线程的全息图数值重建代码范例（High Performance）如下：","category":"page"},{"location":"manual/processing/","page":"标准全息处理","title":"标准全息处理","text":"FFTW.set_num_threads(Sys.CPU_THREADS)\nPr = plan_rfft(holo)\n# scale是手动调整的\nscale = 1500\nre_img = reconst(holo, Pr, scale; nthreads=true)","category":"page"},{"location":"manual/processing/","page":"标准全息处理","title":"标准全息处理","text":"如果你坚持要完整的重建像，则范例如下：","category":"page"},{"location":"manual/processing/","page":"标准全息处理","title":"标准全息处理","text":"FFTW.set_num_threads(Sys.CPU_THREADS)\nP = plan_fft(holo)\n# scale是手动调整的\nscale = 1500\nre_img = reconst(holo, P, scale; nthreads=true)","category":"page"},{"location":"manual/processing/","page":"标准全息处理","title":"标准全息处理","text":"如果你还需要对图像进行旋转（建议仅在需要观测合适的重建像时使用），则范例如下","category":"page"},{"location":"manual/processing/","page":"标准全息处理","title":"标准全息处理","text":"FFTW.set_num_threads(Sys.CPU_THREADS)\nP = plan_fft(holo)\n# scale是手动调整的\nscale = 1500\nre_img = reconst(holo, P, scale; shift=true, nthreads=true)","category":"page"},{"location":"manual/processing/","page":"标准全息处理","title":"标准全息处理","text":"note: Note\n你可能不确定shift采用true还是false，我建议你都试一下，然后用imshow函数看一下图像的区别。","category":"page"},{"location":"#HoloProcessing-中文文档","page":"主页","title":"HoloProcessing 中文文档","text":"","category":"section"},{"location":"","page":"主页","title":"主页","text":"科学计算对性能一直有着最高的需求，但目前各领域的专家却大量使用较慢的动态语言来开展他们的日常工作。 偏爱动态语言有很多很好的理由，因此我们不会舍弃动态的特性。 幸运的是，现代编程语言设计与编译器技术可以大大消除性能折衷（trade-off），并提供有足够生产力的单一环境进行原型设计，而且能高效地部署性能密集型应用程序。 Julia 语言在这其中扮演了这样一个角色：它是一门灵活的动态语言，适合用于科学计算和数值计算，并且性能可与传统的静态类型语言媲美。","category":"page"},{"location":"","page":"主页","title":"主页","text":"由于 Julia 的编译器和其它语言比如 Python 或 R 的解释器有所不同，一开始你可能发现 Julia 的性能并不是很突出。 如果你觉得速度有点慢，我们强烈建议在尝试其他功能前，先读一读文档中","category":"page"}]
}
